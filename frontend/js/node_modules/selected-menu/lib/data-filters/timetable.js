'use strict';

var objectHelper = require('object-helper');

function setup(loadedModel, menuItem, node, row) {
    if(node.type !== 'origin') {
        return;
    }

    var rowLookup       = {};
    var originFoldable  = menuItem.addFoldable('Scenario Editor', 200);

    var that      = this;
    var weStarted = false;

    originFoldable.child.on('unfolded', function() {
        that.emit('showSimulate', true);
        that.tool.emit('refresh');
    });

    function resetShowSimulate() {
        that.emit('showSimulate', false);
        that.tool.emit('refresh');
    }

    originFoldable.child.on('folded',    resetShowSimulate);
    menuItem.child.on      ('folded',    resetShowSimulate);
    originFoldable.child.on('destroyed', resetShowSimulate);

    var timeStepChanged = function(previousStep, step, value, node) {
        if(!loadedModel.loadedScenario) {
            return;
        }

        if(step.match(/^$|^-$/) !== null) {
            return true;
        }

        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            loadedModel.loadedScenario.data[node.id] = {
                id:       loadedModel.generateId(),
                scenario: loadedModel.loadedScenario,
                node:     node,
                steps:    {}
            };

            timetable             = loadedModel.loadedScenario.data[node.id];
            timetable.steps[step] = value;
            return;
        }

        // If there's already a step on this key, leave everything as is.
        if(timetable.steps[step] !== undefined) {
            // Returning true restores the value to previous accepted change.
            return true;
        }

        // Get the foldable with all timerows.
        var foldable = originFoldable;

        // Set the step and row lookup and delete the old step in the data object.
        timetable.steps[step]    = value;
        rowLookup[node.id][step] = rowLookup[node.id][previousStep];

        delete timetable.steps[previousStep];
        delete rowLookup[node.id][previousStep];

        // Get the indexes after data update.
        var a = Object.keys(rowLookup[node.id]);
        // And the current row index.
        var i = a.indexOf(step);

        // If the row index is in the list, insert it before the next element.
        // If it's on the edge, append it to the end.
        if(i + 1 < a.length) {
            foldable.child.root.insertBefore(rowLookup[node.id][a[i]].root, rowLookup[node.id][a[i + 1]].root);
        } else {
            foldable.child.root.appendChild(rowLookup[node.id][a[i]].root);
        }

        // Redraw new data.
        that.tool.emit('refresh');
    };

    var timeValueChanged = function(step, value, node) {
        if(!loadedModel.loadedScenario) {
            return;
        }

        if(value === '') {
            return true;
        }

        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            loadedModel.loadedScenario.data[node.id] = {
                id:       loadedModel.generateId(),
                /*scenario: loadedModel.loadedScenario,
                node:     node,*/
                steps:    {}
            };

            timetable = loadedModel.loadedScenario.data[node.id];
        }

        timetable.steps[step] = parseInt(value);

        that.tool.emit('refresh');
    };

    var rowDeleted = function(step, value, node, foldable) {
        if(!loadedModel.loadedScenario) {
            return;
        }

        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            return;
        }

        delete timetable.steps[step];

        if(objectHelper.size.call(timetable.steps) === 0) {
            foldable.labelRow.root.style.display = 'none';
        }

        that.tool.emit('refresh');
    };

    var addStepCallback = function(evt) {
        var node     = evt.target.node     || evt.target.parentElement.node;
        var foldable = evt.target.foldable || evt.target.parentElement.foldable;
        if(!node || !foldable) {
            return;
        }

        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            var row = foldable.addTimeRow(0, 0, node, timeStepChanged, timeValueChanged, rowDeleted);
            loadedModel.loadedScenario.data[node.id] = {
                id:        loadedModel.generateId(),
                /*scenario:  loadedModel.loadedScenario,
                node:      node,*/
                steps:     {'0': 0}
            };

            rowLookup[node.id]['0'] = row;
            timetable = loadedModel.loadedScenario.data[node.id];
        } else {
            var lastStep = parseInt(objectHelper.lastKey.call(timetable.steps));
            if(isNaN(lastStep)) {
                lastStep = -1;
            }

            lastStep += 1;
            var row = foldable.addTimeRow(lastStep, 0, node, timeStepChanged, timeValueChanged, rowDeleted);

            timetable.steps[lastStep]    = 0;
            rowLookup[node.id][lastStep] = row;
        }

        if(objectHelper.size.call(timetable.steps) > 0) {
            foldable.labelRow.root.style.display = 'block';
        }

        that.tool.emit('refresh');
    };

    // Create the folded item for this origin node.
    //originFoldable.addInput('Baseline');
    var realNumbers = originFoldable.addCheckbox('Use real numbers'),
        addStep     = originFoldable.addButton('Add Step', addStepCallback),
        labelRow    = originFoldable.addSeparator();

    realNumbers.onCheck(function() {
        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            loadedModel.loadedScenario.data[node.id] = {
                id:        loadedModel.generateId(),
                /*scenario:  loadedModel.loadedScenario,
                node:      node,*/
                steps:     {'0': 0}
            };

            timetable = loadedModel.loadedScenario.data[node.id];
        }

        timetable.realNumbers = true;
        that.tool.emit('refresh');
    });

    realNumbers.onUncheck(function() {
        var timetable = loadedModel.loadedScenario.data[node.id];
        if(!timetable) {
            return;
        }

        timetable.realNumbers = false;
        that.tool.emit('refresh');
    });

    if(loadedModel.loadedScenario.data[node.id] && loadedModel.loadedScenario.data[node.id].realNumbers) {
        realNumbers.check();
    }

    var stepLabel   = originFoldable.addLabel('Step'),
        changeLabel = originFoldable.addLabel('Change');

    labelRow.root.style.padding       = '0px 8px';
    labelRow.root.style['margin-top'] = '16px';

    stepLabel.root.style.display      = 'inline-block';
    changeLabel.root.style.display    = 'inline-block';

    stepLabel.root.style.padding      = '0px';
    changeLabel.root.style.padding    = '0px';

    stepLabel.root.style.margin       = '0px 4px';
    changeLabel.root.style.margin     = '0px 4px';

    stepLabel.setWidth('20%');
    changeLabel.setWidth('55%');

    labelRow.appendChild(stepLabel);
    labelRow.appendChild(changeLabel);

    originFoldable.labelRow                    = labelRow;
    originFoldable.labelRow.root.style.display = 'none';

    addStep.root.node        = node;
    addStep.root.foldable    = originFoldable;
    addStep.root.loadedModel = loadedModel;

    if(!rowLookup[node.id]) {
        rowLookup[node.id] = {};
    }

    if(!loadedModel.loadedScenario.data[node.id] || !loadedModel.loadedScenario.data[node.id].steps) {
        return originFoldable;
    }

    originFoldable.labelRow.root.style.display = 'block';

    objectHelper.forEach.call(loadedModel.loadedScenario.data[node.id].steps, function(value, step) {
        var row = originFoldable.addTimeRow(step, value, node, timeStepChanged, timeValueChanged, rowDeleted);
        rowLookup[node.id][step] = row;
    });

    return originFoldable;
}

module.exports = {
    property: 'timetable',
    type:     'system',
    setup:    setup
};