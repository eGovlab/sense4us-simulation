'use strict';

/**
 * The tool class that will be the entrypoint for users of the tool.
 * @module tool 
 */

var Emitter      = require('emitter'),
    network      = require('network'),
    breakout     = require('breakout'),
    Promise      = require('promise'),
    Model        = require('model'),
    Scenario     = require('scenario'),
    objectHelper = require('object-helper'),

    createNode = require('structures').createNode,
    createLink = require('structures').createLink;

var remoteNodeHelper     = require('./lib/remote_node_helper'),
    remoteLinkHelper     = require('./lib/remote_link_helper'),
    remoteScenarioHelper = require('./lib/remote_scenario_helper');

function* generateModelId() {
    var i = 0;
    while(true) {
        yield i++;
    }
}

/**
 * @description Tool constructor
 * @see {@link tool/Tool}
 * @class
 *
 * @param {object} config - Config object.
 */
function Tool(config) {
    this.idGenerator = generateModelId();
    this.loadedModel = new Model(this.idGenerator.next().value);
    this.savedModels = {
        local:  {},
        synced: {}
    };

    this.savedModels.local[this.loadedModel.id] = this.loadedModel;

    this.static = {};
    this.config = {
        container:     config.container      || null,
        protocol:      config.protocol       || null,
        hostname:      config.hostname       || null,
        port:          parseInt(config.port) || null,
        userFilter:    config.userFilter     || null,
        projectFilter: config.projectFilter  || null,
        url:           config.url            || null
    };

    this.listeners   = {};
}

Tool.prototype = {__proto__: Emitter.prototype};
Tool.prototype.scenariosToJson = function(scenarios) {
    var scenariosData = [];
    objectHelper.forEach.call(scenarios, function(scenario) {
        var scenarioData = {
            id:                scenario.id,
            syncId:            scenario.syncId,
            name:              scenario.name,
            maxIterations:     scenario.maxIterations,
            measurement:       scenario.measurement,
            measurementAmount: scenario.measurementAmount,
            timeStepN:         scenario.timeStepN
        };

        scenarioData.tables = objectHelper.map.call(scenario.data, function(table) {
            return {
                id:          table.id,
                syncId:      table.syncId,
                timetable:   table.steps,
                realNumbers: table.realNumbers || false
            };
        });

        scenariosData.push(scenarioData);
    });

    return scenariosData;
};

/**
 * @description Delete a model by given id.
 * @name deleteModel
 * @function
 *
 * @param {integer} [id] - Model id. If the id is omitted, the currently loaded model is deleted.
 * @returns {promise}
 */

Tool.prototype.deleteSyncedModel = function(id) {
    var url           = this.config.url,
        userFilter    = this.config.userFilter,
        projectFilter = this.config.projectFilter,
        savedModels   = this.savedModels,
        loadedModel   = this.loadedModel,
        that          = this;

    return network.DELETE(
        url,
        '/models/' + userFilter + '/' + projectFilter + '/' + id,
        {}
    ).then(function(response) {
        if(!savedModels.synced[id]) {
            return Promise.reject(new Error(
                'DELETE response succeeded, ' + 
                'but there is no such model loaded into the tool.' + 
                'Can\'t return a model.'
            ));
        }

        var removedModel = savedModels.synced[id];
        if(removedModel && savedModels.local[removedModel.id]) {
            delete savedModels.local[removedModel.id];
        }

        delete savedModels.synced[id];
        that.emit('deletedModel', id);
        that.emit('deletedSyncedModel', id);

        if(loadedModel.syncId === id) {
            return that.loadModel().then(function() {
                return removedModel;
            });
        }

        return removedModele;
    });
};

Tool.prototype.deleteLocalModel = function(id) {
    if(!this.savedModels.local[id]) {
        return Promise.reject(new Error('No local model under that id.'));
    }

    var removedModel = this.savedModels.local[id];

    delete this.savedModels.local[id];
    this.emit('deletedModel', id);
    this.emit('deletedLocalModel', id);

    if(id === this.loadedModel.id) {
        return this.loadModel().then(function() {
            return removedModel;
        });
    }

    return Promise.resolve(removedModel);
};

Tool.prototype.deleteModel = function(id) {
    // Id is omitted, delete the currently loaded model.
    if(id === undefined) {
        if(!this.loadedModel || (!this.loadedModel.syncId && !this.loadedModel.id)) {
            return Promise.reject(new Error('No model is loaded. This is unexpected behaviour.'));
        }

        id = this.loadedModel.syncId || this.loadedModel.id;
    }

    if(!this.savedModels.synced[id]) {
        return this.deleteLocalModel(id);
    }

    return this.deleteSyncedModel(id);
};

/**
 * @description Save a model by given id.
 * @name saveModel
 * @function
 *
 * @param {integer} [id] - Model id. If the id is omitted, the currently loaded model is saved.
 * @returns {promise}
 */
Tool.prototype.saveModel = function(id) {
    var url           = this.config.url,
        userFilter    = this.config.userFilter,
        projectFilter = this.config.projectFilter,
        savedModels   = this.savedModels,
        loadedModel   = this.loadedModel,
        that          = this;

    var data = {
        modelId:   loadedModel.syncId,
        settings:  loadedModel.settings,
        nodes:     breakout.nodes(loadedModel),
        links:     breakout.links(loadedModel),
        scenarios: this.scenariosToJson(loadedModel.scenarios)
    };

    console.log(data);

    return network.POST(
        url,
        '/models/' + userFilter + '/' + projectFilter +'/save',
        data
    ).then(function(response) {
        response = JSON.parse(response.responseText);

        loadedModel.synced         = true;
        loadedModel.syncId         = response.response.model.id;
        loadedModel.settings.saved = true;

        var nodes      = response.response.nodes;
        var links      = response.response.links;
        var scenarios  = response.response.scenarios;
        var timetables = response.response.timetables;
        var timesteps  = response.response.timesteps;

        var nodeLookup = {};
        nodes.forEach(function(node) {
            try {
                loadedModel.nodeData[node.id].syncId = node.syncId;
                loadedModel.nodeGui[node.id].syncId  = node.syncId;

                nodeLookup[node.syncId] = loadedModel.nodeData[node.id];
            } catch(err) {
                // Node deleted locally before synchronization was made.
            }
        });

        links.forEach(function(link) {
            try {
                loadedModel.links[link.id].syncId = link.syncId;
            } catch(err) {
                // Link deleted locally before synchronization was made.
            }
        });

        var scenarioLookup = {};
        scenarios.forEach(function(scenario) {
            loadedModel.scenarios[scenario.id].syncId = scenario.syncId;
            scenarioLookup[scenario.syncId] = loadedModel.scenarios[scenario.id];
        });

        var timetableLookup = {};
        timetables.forEach(function(timetable) {
            scenarioLookup[timetable.scenario].data[nodeLookup[timetable.node].id].syncId = timetable.syncId;
            timetableLookup[timetable.syncId] = scenarioLookup[timetable.scenario].data[nodeLookup[timetable.node]];
        });

        that.emit('savedModel', loadedModel, loadedModel.syncId);
        return loadedModel;
    });
};

Tool.prototype.loadSyncedModel = function(id) {
    if(this.savedModels.synced[id]) {
        this.loadedModel = this.savedModels.local[id];
        this.emit('loadedModel', this.loadedModel, id);

        return Promise.resolve(this.loadedModel);
    }

    var url           = this.config.url,
        userFilter    = this.config.userFilter,
        projectFilter = this.config.projectFilter,
        savedModels   = this.savedModels,
        loadedModel   = this.loadedModel,
        that          = this;
    return network.GET(
        url,
        '/models/' + userFilter + '/' + projectFilter + '/bundle/' + id
    ).then(function(response) {
        response = JSON.parse(response.responseText);
        var settings   = response.response.model,
            nodes      = response.response.nodes,
            links      = response.response.links,
            scenarios  = response.response.scenarios,
            timetables = response.response.timetables,
            timesteps  = response.response.timesteps;

        var newState = new Model();

        newState.synced = true;
        newState.syncId = settings.id;

        delete newState.scenarios;

        var highestId = 0;

        newState.scenarios = {};

        newState.settings.name    = settings.name;
        newState.settings.offsetX = settings.pan_offset_x;
        newState.settings.offsetY = settings.pan_offset_y;
        newState.settings.zoom    = settings.zoom;

        if(settings.deleted === true) {
            newState.settings.deleted = true;
        }

        var nodeMap = remoteNodeHelper.convertRemoteNodeArray(
            nodes,
            highestId
        );

        newState.nodeData = nodeMap.data;
        newState.nodeGui  = nodeMap.gui;
        highestId         = nodeMap.highestId;

        var linkMap = remoteLinkHelper.convertRemoteLinkArray(
            links,
            highestId
        )

        newState.links = linkMap.links;
        highestId      = linkMap.highestId;

        objectHelper.forEach.call(linkMap.nodeConnections, function(linkArray, nodeId) {
            newState.nodeGui[nodeId].links = linkArray;
        });

        var scenarioMap = remoteScenarioHelper.convertRemoteScenarioArray(
            scenarios,
            timetables,
            timesteps,
            highestId
        );

        highestId               = scenarioMap.highestId;
        newState.scenarios      = scenarioMap.scenarios;
        newState.loadedScenario = scenarioMap.loadedScenario;

        if(objectHelper.size.call(newState.scenarios) === 0) {
            var scenario                    = new Scenario(newState);
            newState.scenarios[scenario.id] = scenario;
            newState.loadedScenario         = scenario;
        }

        newState.nextId = ++highestId;

        return newState;
    }).then(function(model) {
        that.loadedModel = model;
        that.savedModels.synced[that.loadedModel.syncId] = that.loadedModel;

        that.emit('loadedModel',       that.loadedModel, that.loadedModel.syncId);
        that.emit('loadedSyncedModel', that.loadedModel, that.loadedModel.syncId);

        return that.loadedModel;
    });
};

Tool.prototype.loadLocalModel = function(id) {
    if(!this.savedModels.local[id]) {
        return Promise.reject(new Error('No local model under that id.'));
    }

    this.loadedModel = this.savedModels.local[id];
    this.emit('loadedModel', this.loadedModel, id);

    return Promise.resolve(this.loadedModel);
};

/**
 * @description Load a model by given id.
 * @name loadModel
 * @function
 *
 * @param {integer} id - Model id.
 * @returns {promise}
 * @fires module:model~Model#modelLoaded
 * @fires module:model~Model#errorLoadingModel
 */
Tool.prototype.loadModel = function(id) {
    if(id === undefined) {
        var model = objectHelper.last.call(this.savedModels.local);
        if(!model) {
            model = objectHelper.last.call(this.savedModels.synced);

            if(!model) {
                return this.newModel();
            }

            return this.loadSyncedModel(model.id);
        }

        return this.loadLocalModel(model.id);
    }

    if(typeof id !== 'number') {
        return Promise.reject(new Error('Id given to loadModel is either undefined or not a number.'));
    }

    if(this.savedModels.synced[id]) {
        return this.loadSyncedModel(id);
    }

    if(this.savedModels.local[id]) {
        return this.loadLocalModel(id);
    }

    return this.loadSyncedModel(id);
};

Tool.prototype.newModel = function() {
    this.loadedModel = new Model(this.idGenerator.next().value);
    this.savedModels.local[this.loadedModel.id] = this.loadedModel;

    this.emit('loadedModel', this.loadedModel);
    this.emit('newModel',    this.loadedModel);
    return Promise.resolve(this.loadedModel);
};

/**
 * @description Select the first node matchind id or string. Can't query both at the same time.
 * @name selectNode
 * @function
 *
 * @param {integer} id - Node id.
 * @param {string} name - Node name.
 * @fires module:model~Model#refresh
 * @fires module:model~Model#resetUI
 * @fires module:model~Model#selected
 */
Tool.prototype.selectNode = function(query) {
    return this.loadedModel.selectNode(query);
};

/**
 * @description Helper method to select node by prototype id.
 * @name selectNodeByPrototypeId
 * @function
 *
 * @param {string} prototypeId - Prototype id.
 */
Tool.prototype.selectNodeByPrototypeId = function(prototypeId) {
    return this.loadedModel.selectNodeByPrototypeId(prototypeId);
};

/**
 * @description Undo the last action of the selected model.
 * @name undo
 * @function
 */
Tool.prototype.undo = function() {
    if(this.history.length === 0) {
        return;
    }

    var lastAction = this.history.splice(this.history.length - 1, 1)[0];
    this.revertedHistory.push(lastAction);

    switch(lastAction.action.toUpperCase()) {
        case 'NEWNODE':
            var data = lastAction.data;
            this.emit(data.data.id, 'deleteNode');
            break;
        case 'NEWLINK':
            var link = lastAction.data.link;
            this.emit(link.id, 'deleteLink');
            break;

        case 'DELETENODE':
            var data = lastAction.data;
            this.nodeData[data.data.id] = data.data;
            this.nodeGui[data.gui.id]   = data.gui;

            data.links.forEach(function(l) {
                this.nodeGui[l.node1].links.push(l.id);
                this.nodeGui[l.node2].links.push(l.id);

                this.links[l.id] = l;
            }, this);

            break;

        case 'DELETELINK':
            var link = lastAction.data.link;
            this.links[link.id] = link;

            this.nodeGui[link.node1].links.push(link.id);
            this.nodeGui[link.node2].links.push(link.id);
            break;
    }

    /**
     * @description Latest action in the history chain was undone.
     * @event undone
     * @memberof module:model/statusEvents
     * @example tool.addListener('undone', function() {
     *     console.log('History state undone.');
     * });
     */
    this.emit('undone');

    this.selected = false;
    this.emit(null, 'select', 'refresh', 'resetUI');
};

/**
 * @description Create a node with the given name
 * @name deleteSelected
 * @function
 */
Tool.prototype.deleteSelected = function() {
    return this.loadedModel.deleteSelected();
};

/**
 * @description Delete a node under the given id.
 * @name deleteNode 
 * @function
 *
 * @param {string} nodeId - The node id to delete.
 */
Tool.prototype.deleteNode = function(id) {
    return this.loadedModel.deleteNode(id);
};

/**
 * @description Delete a link under the given id.
 * @name deleteLink
 * @function
 *
 * @param {string} linkId - The link id to delete.
 */
Tool.prototype.deleteLink = function(id) {
    return this.loadedModel.deleteLink(id);
};

/**
 * @description Create a node with the given name
 * @name createNode
 * @function
 *
 * @param {string} name - Name the node should inherit. 
 * @param {string} type - Node type. 
 * @param {string} prototypeId - Prototype id.
 */
Tool.prototype.createNode = function(name, type, role, prototypeId) {
    if(    typeof name !== 'string'
        || typeof type !== 'string'
        || typeof role !== 'string') {
        throw new Error('Couldn\'t create node since information is lacking. Requires strings: name, type, role.');
    }

    createNode(this, {
        name:        name,
        prototypeId: prototypeId,
        role:        role.toUpperCase()
    }, {}, type || 'template');
};

/**
 * @description Create a node with the given structure.
 * @name createNodeByStructure
 * @function
 *
 * @param {object} nodeData - nodeData structure. 
 * @param {object} nodeGui - nodeGui structure. 
 */
Tool.prototype.createNodeByStructure = function(data, gui) {
    gui.selected = false;
    this.loadedModel.createNode(data, gui, data.type);
};

/**
 * @description Redo the last undone action of the selected model.
 * @name redo
 * @function
 */
Tool.prototype.redo = function() {
    if(this.loadedModel.revertedHistory.length === 0) {
        return;
    }

    var lastAction = this.loadedModel.revertedHistory.splice(this.loadedModel.revertedHistory.length - 1, 1)[0];
    this.loadedModel.history.push(lastAction);

    switch(lastAction.action.toUpperCase()) {
        case 'NEWNODE':
            var data = lastAction.data;
            this.loadedModel.nodeData[data.data.id] = data.data;
            this.loadedModel.nodeGui[data.gui.id]   = data.gui;
            break;
        case 'NEWLINK':
            var link = lastAction.data.link;
            this.loadedModel.links[link.id] = link;

            this.loadedModel.nodeGui[link.node1].links.push(link.id);
            this.loadedModel.nodeGui[link.node2].links.push(link.id);
            break;

        case 'DELETENODE':
            var data = lastAction.data;
            this.loadedModel.emit(data.data.id, 'deleteNode');
            break;

        case 'DELETELINK':
            var link = lastAction.data.link;
            this.loadedModel.emit(link.id, 'deleteLink');
            break;
    }

    /**
     * @description Latest action in the history chain was redone.
     * @event redone
     * @memberof module:model/statusEvents
     * @example tool.addListener('redone', function() {
     *     console.log('History state redone.');
     * });
     */
    this.loadedModel.emit('redone');

    this.loadedModel.selected = false;
    this.loadedModel.emit('refresh')
    this.loadedModel.emit('resetUI');
};

/**
 * @description Fetches all the models available for given user filter and project filter.
 * @name getAllModels
 * @function
 * @returns {promise}
 */
Tool.prototype.getAllModels = function(callback) {
    var userFilter    = this.config.userFilter,
        projectFilter = this.config.projectFilter,
        url           = this.config.url;

    return network.GET(
        url,
        '/models/' + userFilter + '/' + projectFilter + '/all'
    ).then(function(response) {
        response = JSON.parse(response.responseText);
        return response.response;
    });
};

var createPopup = require('./lib/create_popup.js');
Tool.prototype.popup = function(config) {
    var popup = createPopup(config);

    // Given config was invalid and no popup should be created.
    if(popup === false) {
        console.error(config, 'given to popup event.');
        return;
    }

    this.config.container.insertBefore(
        popup.root,
        this.config.container.firstChild
    );

    return Promise.resolve(popup);
};

module.exports = Tool;