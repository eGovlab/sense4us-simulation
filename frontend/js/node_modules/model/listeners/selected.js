'use strict';

var objectHelper = require('object-helper'),
    NewUI        = require('new_ui');

var Colors = NewUI.Colors;

var modelling    = require('settings').modelling;
var roles        = {};

modelling.forEach(function(group) {
    group.header = group.header.toUpperCase();
    if(!roles[group.header]) {
        roles[group.header] = [];
    }

    roles[group.header] = roles[group.header].concat(group.images);
});

var linkModellingFilter = [
    {property: 'type',        type: 'dropdown', values: ['halfchannel', 'fullchannel']},

    {property: 'threshold',   type: 'input', check: function(value) {
        var match = value.match(/^-?\d+\.?\d*$/);
        if(match === null) {
            return false;
        }

        return true;
    }, set: function(value){return parseFloat(value);}}, 

    {property: 'coefficient', type: 'input', check: function(value) {
        var match = value.match(/^-?\d+\.?\d*$/);
        if(match === null) {
            return false;
        }
        
        return true;
    }, set: function(value){return parseFloat(value);}},

    {property: 'timelag',     type: 'input', check: function(value) {
        var match = value.match(/^\d+$/);
        if(match === null) {
            return false;
        }

        return true;
    }, set: function(value){return parseInt(value);}},

    //{property: 'bidirectional', type: 'checkbox'},

    {property: 'bidirectionalTimelag', type: 'input', check: function(value) {
        var match = value.match(/^\d+$/);
        if(match === null) {
            return false;
        }

        return true;
    }, set: function(value) {
        return parseInt(value);
    }, showCondition: function(link) {
        console.log(link);
        return link.bidirectional;
    }}
],
    dataModellingFilter = [
    {property: 'timetable', type: 'system',
    setup: function(loadedModel, menuItem, node, row) {
        if(node.type !== 'origin') {
            return;
        }

        var rowLookup       = {};
        var originFoldable  = menuItem.addFoldable('Scenario Editor', 200);

        var weStarted = false;
        originFoldable.child.on('unfolded', function() {
            var isShowing = loadedModel.static.showSimulate;
            if(!isShowing) {
                loadedModel.emit('refresh');
                loadedModel.emit(true, 'showSimulate');

                weStarted = true;
            }
        });

        function resetShowSimulate() {
            if(weStarted && loadedModel.static.showSimulate === true) {
                loadedModel.static.showSimulate = false;
                loadedModel.emit('refresh');
                loadedModel.emit(false, 'showSimulate');
                weStarted = false;
            }
        }

        originFoldable.child.on('folded',    resetShowSimulate);
        menuItem.child.on      ('folded',    resetShowSimulate);
        originFoldable.child.on('destroyed', resetShowSimulate);

        var timeStepChanged = function(previousStep, step, value, node) {
            if(!loadedModel.loadedScenario) {
                return;
            }

            if(step.match(/^$|^-$/) !== null) {
                return true;
            }

            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                loadedModel.loadedScenario.data[node.id] = {
                    id:       loadedModel.generateId(),
                    scenario: loadedModel.loadedScenario,
                    node:     node,
                    steps:    {}
                };

                timetable             = loadedModel.loadedScenario.data[node.id];
                timetable.steps[step] = value;
                return;
            }

            // If there's already a step on this key, leave everything as is.
            if(timetable.steps[step] !== undefined) {
                // Returning true restores the value to previous accepted change.
                return true;
            }

            // Get the foldable with all timerows.
            var foldable = originFoldable;

            // Set the step and row lookup and delete the old step in the data object.
            timetable.steps[step]    = value;
            rowLookup[node.id][step] = rowLookup[node.id][previousStep];

            delete timetable.steps[previousStep];
            delete rowLookup[node.id][previousStep];

            // Get the indexes after data update.
            var a = Object.keys(rowLookup[node.id]);
            // And the current row index.
            var i = a.indexOf(step);

            // If the row index is in the list, insert it before the next element.
            // If it's on the edge, append it to the end.
            if(i + 1 < a.length) {
                foldable.child.root.insertBefore(rowLookup[node.id][a[i]].root, rowLookup[node.id][a[i + 1]].root);
            } else {
                foldable.child.root.appendChild(rowLookup[node.id][a[i]].root);
            }

            // Redraw new data.
            loadedModel.emit('refresh');
        };

        var timeValueChanged = function(step, value, node) {
            if(!loadedModel.loadedScenario) {
                return;
            }

            if(value === '') {
                return true;
            }

            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                loadedModel.loadedScenario.data[node.id] = {
                    id:       loadedModel.generateId(),
                    /*scenario: loadedModel.loadedScenario,
                    node:     node,*/
                    steps:    {}
                };

                timetable = loadedModel.loadedScenario.data[node.id];
            }

            timetable.steps[step] = parseInt(value);

            loadedModel.emit('refresh');
        };

        var rowDeleted = function(step, value, node, foldable) {
            if(!loadedModel.loadedScenario) {
                return;
            }

            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                return;
            }

            delete timetable.steps[step];

            if(objectHelper.size.call(timetable.steps) === 0) {
                foldable.labelRow.root.style.display = 'none';
            }

            loadedModel.emit('refresh');
        };

        var addStepCallback = function(evt) {
            var node     = evt.target.node     || evt.target.parentElement.node;
            var foldable = evt.target.foldable || evt.target.parentElement.foldable;
            if(!node || !foldable) {
                return;
            }

            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                var row = foldable.addTimeRow(0, 0, node, timeStepChanged, timeValueChanged, rowDeleted);
                loadedModel.loadedScenario.data[node.id] = {
                    id:        loadedModel.generateId(),
                    /*scenario:  loadedModel.loadedScenario,
                    node:      node,*/
                    steps:     {'0': 0}
                };

                rowLookup[node.id]['0'] = row;
            } else {
                var lastStep = parseInt(objectHelper.lastKey.call(timetable.steps));
                if(isNaN(lastStep)) {
                    lastStep = -1;
                }

                lastStep += 1;
                var row = foldable.addTimeRow(lastStep, 0, node, timeStepChanged, timeValueChanged, rowDeleted);

                timetable.steps[lastStep]    = 0;
                rowLookup[node.id][lastStep] = row;
            }

            if(objectHelper.size.call(timetable.steps) > 0) {
                foldable.labelRow.root.style.display = 'block';
            }

            loadedModel.emit('refresh');
        };

        // Create the folded item for this origin node.
        //originFoldable.addInput('Baseline');
        var realNumbers = originFoldable.addCheckbox('Use real numbers'),
            addStep     = originFoldable.addButton('Add Step', addStepCallback),
            labelRow    = originFoldable.addSeparator();

        realNumbers.onCheck(function() {
            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                loadedModel.loadedScenario.data[node.id] = {
                    id:        loadedModel.generateId(),
                    /*scenario:  loadedModel.loadedScenario,
                    node:      node,*/
                    steps:     {'0': 0}
                };

                timetable = loadedModel.loadedScenario.data[node.id];
            }

            timetable.realNumbers = true;
            loadedModel.emit('refresh');
        });

        realNumbers.onUncheck(function() {
            var timetable = loadedModel.loadedScenario.data[node.id];
            if(!timetable) {
                return;
            }

            timetable.realNumbers = false;
            loadedModel.emit('refresh');
        });

        if(loadedModel.loadedScenario.data[node.id] && loadedModel.loadedScenario.data[node.id].realNumbers) {
            realNumbers.check();
        }

        var stepLabel   = originFoldable.addLabel('Step'),
            changeLabel = originFoldable.addLabel('Change');

        labelRow.root.style.padding       = '0px 8px';
        labelRow.root.style['margin-top'] = '16px';

        stepLabel.root.style.display      = 'inline-block';
        changeLabel.root.style.display    = 'inline-block';

        stepLabel.root.style.padding      = '0px';
        changeLabel.root.style.padding    = '0px';

        stepLabel.root.style.margin       = '0px 4px';
        changeLabel.root.style.margin     = '0px 4px';

        stepLabel.setWidth('20%');
        changeLabel.setWidth('55%');

        labelRow.appendChild(stepLabel);
        labelRow.appendChild(changeLabel);

        originFoldable.labelRow                    = labelRow;
        originFoldable.labelRow.root.style.display = 'none';

        addStep.root.node        = node;
        addStep.root.foldable    = originFoldable;
        addStep.root.loadedModel = loadedModel;

        if(!rowLookup[node.id]) {
            rowLookup[node.id] = {};
        }

        if(!loadedModel.loadedScenario.data[node.id] || !loadedModel.loadedScenario.data[node.id].steps) {
            return originFoldable;
        }

        originFoldable.labelRow.root.style.display = 'block';

        objectHelper.forEach.call(loadedModel.loadedScenario.data[node.id].steps, function(value, step) {
            var row = originFoldable.addTimeRow(step, value, node, timeStepChanged, timeValueChanged, rowDeleted);
            rowLookup[node.id][step] = row;
        });

        return originFoldable;
    }},

    {property: 'name',        type: 'input', check: function() {
        return true;
    }},
    {property: 'description', type: 'input', check: function() {
        return true;
    }},
    {property: 'baseline',    type: 'input', check: function(value) {
        var match = value.match(/^-?\d+$/);
        if(match === null) {
            return false;
        }

        return true;
    }, set: function(value) {
        return parseFloat(value);
    }}
],
    guiModellingFilter  = [
    {property: 'color',         type: 'input', check: function(value) {
        var match = value.match(/^#[0-9a-fA-F]{3}$|^#[0-9a-fA-F]{6}$/);
        return match !== null;
    }},
    {property: 'avatar',        type: 'iconGroup', groups: roles}
];

function getInput(loadedModel, menuItem, inputs, iterator) {
    var input;
    if(iterator < inputs.length) {
        input = inputs[iterator];
    } else {
        input = menuItem.addInput();
        inputs.push(input);

        input.defaultValue(function() {
            if(!input.changeProperty) {
                return '';
            }

            return input.changeObject[input.changeProperty];
        });

        input.onChange(function() {
            var value = input.getValue();
            if(!input.changeCheck(value)) {
                input.setValue(input.changeObject[input.changeProperty]);
                return;
            }

            if(input.setObjectValue) {
               input.changeObject[input.changeProperty] = input.setObjectValue.call(input, value);
            } else {
               input.changeObject[input.changeProperty] = value;
            }

            loadedModel.floatingWindows.forEach(function(floatingWindow) {
                floatingWindow.refresh();
            });

            loadedModel.emit([value, input.changeProperty, input.changeObject], 'dataModified');
            loadedModel.emit('refresh');
        });
    }

    return input;
}

function getButton(loadedModel, menuItem, buttons, iterator) {
    var button;
    if(iterator < buttons.length) {
        button = buttons[iterator];
        button.removeEvents();
    } else {
        button = menuItem.addButton();
        buttons.push(button);
    }

    return button;
}

function getDropdown(loadedModel, menuItem, dropdowns, iterator) {
    var dropdown;
    if(iterator < dropdowns.length) {
        dropdown = dropdowns[iterator];
    } else {
        dropdown = menuItem.addDropdown();
        dropdowns.push(dropdown);

        dropdown.defaultValue(function() {
            if(!dropdown.changeProperty) {
                return '';
            }

            return dropdown.changeObject[dropdown.changeProperty];
        });

        dropdown.onChange(function() {
            var value = dropdown.getValue();

            dropdown.changeObject[dropdown.changeProperty] = value;

            loadedModel.emit([value, dropdown.changeProperty, dropdown.changeObject], 'dataModified');
            loadedModel.emit('refresh');
        });
    }

    return dropdown;
}

function getCheckbox(loadedModel, menuItem, checkboxes, iterator) {
    var checkbox;
    if(iterator < checkboxes.length) {
        checkbox = checkboxes[iterator];
    } else {
        checkbox = menuItem.addCheckbox();
        checkboxes.push(checkbox);

        checkbox.onCheck(function() {
            if(checkbox.setObjectValue) {
                var v = checkbox.setObjectValue(true);
                checkbox.changeObject[checkbox.changeProperty] = v;
                loadedModel.emit([v, dropdown.changeProperty, dropdown.changeObject], 'dataModified');
            } else {
                checkbox.changeObject[checkbox.changeProperty] = true;
                loadedModel.emit([true, dropdown.changeProperty, dropdown.changeObject], 'dataModified');
            }

        });

        checkbox.onUncheck(function() {
            if(checkbox.setObjectValue) {
                var v = checkbox.setObjectValue(false);
                checkbox.changeObject[checkbox.changeProperty] = v;
                loadedModel.emit([v, dropdown.changeProperty, dropdown.changeObject], 'dataModified');
            } else {
                checkbox.changeObject[checkbox.changeProperty] = false;
                loadedModel.emit([false, dropdown.changeProperty, dropdown.changeObject], 'dataModified');
            }

        });
    }

    return checkbox;
}

function getSliders(loadedModel, menuItem, sliders, iterator) {

}

function getIconGroup(loadedModel, menuItem, iconGroups, iterator) {
    var iconGroup;
    if(iterator < iconGroups.length) {
        iconGroup = iconGroups[iterator];

        iconGroup.invalidate();
    } else {
        iconGroup = menuItem.addIconGroup();
        iconGroups.push(iconGroup);

        iconGroup.clicks = [];
        NewUI.Button.prototype.click.call(iconGroup, function(evt) {
            var clickedIcon = evt.target.clickedIcon;
            if(!clickedIcon) {
                return;
            }

            if(iconGroup.changeObject) {
                if(iconGroup.lastActive) {
                    var lastRoot = iconGroup.lastActive.image.root;
                    lastRoot.style.border = 'none';
                }

                iconGroup.lastActive = clickedIcon;
                clickedIcon.image.root.style.border = '4px solid ' + Colors.activeAvatar;

                iconGroup.changeObject[iconGroup.changeProperty] = clickedIcon.currentImage.src;
                loadedModel.emit('refresh');
            }
        });
    }

    return iconGroup;
}

function hideEverything(inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems) {
    inputs.forEach(function(input) {
        input.hide();
    });

    buttons.forEach(function(button) {
        button.buttonContainer.hide();
    });

    dropdowns.forEach(function(dropdown) {
        dropdown.hide();
    });

    checkboxes.forEach(function(checkbox) {
        checkbox.hide();
    });

    sliders.forEach(function(slider) {
        slider.hide();
    });

    iconGroups.forEach(function(iconGroup) {
        iconGroup.hide();
    });

    systems.forEach(function(system) {
        if(!system) {
            return;
        }

        system.destroy();
    });

    systems.splice(0, systems.length);
}

function setupInput(loadedModel, menuItem, inputs, iteration, row, item) {
    var input = getInput(loadedModel, menuItem, inputs, iteration);

    input.changeProperty = row.property;
    input.changeObject   = item;
    input.changeCheck    = row.check;
    
    input.setObjectValue = false;
    if(row.set) {
        input.setObjectValue = row.set;
    }

    input.setLabel(row.property);
    input.refresh();

    if(row.showCondition && !row.showCondition(item)) {
        input.hide();
    } else {
        input.show();
    }

    return input;
}

function setupIconGroup(loadedModel, menuItem, iconGroups, iteration, row, data, gui) {
    var iconGroup = getIconGroup(loadedModel, menuItem, iconGroups, iteration);

    iconGroup.changeProperty = row.property;
    iconGroup.changeObject   = gui;

    iconGroup.setLabel(row.property);

    var iconIterator = 0;
    if(row.groups[data.role]) {
        row.groups[data.role].forEach(function(img) {
            var btn = iconGroup.reuseIcon(loadedModel.CONFIG.url + '/' + img.src, iconIterator);
            btn.root.clickedIcon       = btn;
            btn.image.root.clickedIcon = btn;

            btn.currentImage = img;

            btn.image.root.style.border = 'none';
            btn.image.root.style['border-radius'] = '50%';

            if(gui[row.property] === img.src) {
                btn.image.root.style.border = '4px solid ' + Colors.activeAvatar;
                iconGroup.lastActive = btn;
            }

            iconIterator++;
        });
    }

    if(row.showCondition && !row.showCondition(item)) {
        iconGroup.hide();
    } else {
        iconGroup.show();
    }

    return iconGroup;
}

function setupDropdown(loadedModel, menuItem, dropdowns, iteration, row, item) {
    var dropdown = getDropdown(loadedModel, menuItem, dropdowns, iteration);

    dropdown.changeProperty = row.property;
    dropdown.changeObject   = item;

    dropdown.setLabel(row.property);
    dropdown.replaceValues(row.values);
    dropdown.refresh();

    if(row.showCondition && !row.showCondition(item)) {
        dropdown.hide();
    } else {
        dropdown.show();
    }

    return dropdown;
}

function setupCheckbox(loadedModel, menuItem, checkboxes, iteration, row, item) {
    var checkbox = getCheckbox(loadedModel, menuItem, checkboxes, iteration);

    checkbox.changeProperty = row.property;
    checkbox.changeObject   = item;

    if(item[row.property]) {
        checkbox.check();
    } else {
        checkbox.uncheck();
    }

    checkbox.setLabel(row.property);
    checkbox.refresh();

    if(row.showCondition && !row.showCondition(item)) {
        checkbox.hide();
    } else {
        checkbox.show();
    }

    return checkbox;
}

function setupSystem(loadedModel, menuItem, systems, row, item, indexAt) {
    var container = row.setup(loadedModel, menuItem, item, row);
    if(!container) {
        return;
    }

    if(container.child) {
        menuItem.child.insertChildAt(container.child, indexAt + 1);
        menuItem.child.insertChildAt(container.foldButton, indexAt + 1);
    } else {
        menuItem.child.insertChildAt(container, indexAt);
    }

    systems.push(container);

    return container;
}

function showNodeMenu(loadedModel, menuItem, inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems, nodeData, nodeGui) {
    var inputIterator     = 0,
        buttonIterator    = 0,
        dropdownIterator  = 0,
        checkboxIterator  = 0,
        iconGroupIterator = 0,
        sliderIterator    = 0;

    hideEverything(inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems);

    var deleteButton = getButton(loadedModel, menuItem, buttons, buttonIterator);
    deleteButton.setLabel('Delete selected');
    deleteButton.click(function() {
        if(loadedModel.static.warnAtDelete === false) {
            loadedModel.emit('deleteSelected');
            return;
        }

        var name = loadedModel.nodeData[loadedModel.selected.id].name;
        loadedModel.emit({
            description: 'Do you want to delete ' + name + '?',
            buttons: [
                {
                    background: Colors.warningRed,
                    color:      Colors.white,
                    callback: function(popup) {
                        loadedModel.emit('deleteSelected');
                        popup.destroy();
                    },
                    label: 'Confirm'
                },

                {
                    background: Colors.warningRed,
                    color:      Colors.white,
                    callback: function(popup) {
                        loadedModel.static.warnAtDelete = false;
                        loadedModel.emit('deleteSelected');
                        popup.destroy();
                    },
                    label: 'Confirm and don\'t remind me'
                },

                {
                    background: Colors.white,
                    callback: function(popup) {
                        popup.destroy();
                    },
                    label: 'Cancel'
                }
            ]
        }, 'popup');
        
    });

    deleteButton.setBackground(Colors.warningRed);

    deleteButton.buttonContainer.show();

    var showConditions = [];
    dataModellingFilter.forEach(function(row, indexAt) {
        switch(row.type.toUpperCase()) {
            case 'INPUT':
                var input = setupInput(loadedModel, menuItem, inputs, inputIterator, row, nodeData);
                if(row.showCondition) {
                    showConditions.push({
                        element:  input,
                        callback: row.showCondition
                    });
                }

                inputIterator++;
                break;
            case 'SYSTEM':
                var container = setupSystem(loadedModel, menuItem, systems, row, nodeData, indexAt);
                if(row.showCondition) {
                    showConditions.push({
                        element:  input,
                        callback: row.showCondition
                    });
                }

                break;
        }
    });

    guiModellingFilter.forEach(function(row) {
        switch(row.type.toUpperCase()) {
            case 'INPUT':
                var input = setupInput(loadedModel, menuItem, inputs, inputIterator, row, nodeGui);
                if(row.showCondition) {
                    showConditions.push({
                        element:  input,
                        callback: row.showCondition
                    });
                }

                inputIterator++;
                break;
            case 'ICONGROUP':
                var iconGroup = setupIconGroup(loadedModel, menuItem, iconGroups, iconGroupIterator, row, nodeData, nodeGui);
                if(row.showCondition) {
                    showConditions.push({
                        element:  input,
                        callback: row.showCondition
                    });
                }

                iconGroupIterator++;
                break;
        }
    });

    return showConditions;
}

function showLinkMenu(loadedModel, menuItem, inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems, link) {
    var inputIterator     = 0,
        buttonIterator    = 0,
        dropdownIterator  = 0,
        checkboxIterator  = 0,
        iconGroupIterator = 0,
        sliderIterator    = 0;

    hideEverything(inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems);

    var deleteButton = getButton(loadedModel, menuItem, buttons, buttonIterator);
    deleteButton.setLabel('Delete selected');
    deleteButton.click(function() {
        loadedModel.emit('deleteSelected');
    });

    deleteButton.buttonContainer.show();

    var showConditions = [];
    linkModellingFilter.forEach(function(row) {
        switch(row.type.toUpperCase()) {
            case 'INPUT':
                var input = setupInput(loadedModel, menuItem, inputs, inputIterator, row, link);
                if(row.showCondition) {
                    showConditions.push({
                        element:  input,
                        callback: row.showCondition
                    });
                }

                inputIterator++;
                break;
            case 'DROPDOWN':
                var dropdown = setupDropdown(loadedModel, menuItem, dropdowns, dropdownIterator, row, link);
                if(row.showCondition) {
                    showConditions.push({
                        element:  dropdown,
                        callback: row.showCondition
                    });
                }

                dropdownIterator++;
                break;
            case 'CHECKBOX':
                var checkbox = setupCheckbox(loadedModel, menuItem, checkboxes, checkboxIterator, row, link);
                if(row.showCondition) {
                    showConditions.push({
                        element:  dropdown,
                        callback: row.showCondition
                    });
                }

                checkboxIterator++;
                break;
        }
    });

    return showConditions;
}

function setupSelectedMenu(sidebar, loadedModel) {
    var menuItem = new NewUI.MenuItem(300);

    menuItem.setLabel('Selected');
    menuItem.root.style.display = 'none';

    var inputs     = [],
        buttons    = [],
        dropdowns  = [],
        checkboxes = [],
        sliders    = [],
        iconGroups = [],
        systems    = [];

    var previousSelected = false;
    var showConditions   = null;
    menuItem.refresh = function() {
        if(previousSelected === loadedModel.selected) {
            if(showConditions && showConditions.length > 0) {
                showConditions.forEach(function(condition) {
                    if(condition.callback(previousSelected)) {
                        condition.element.show();
                    } else {
                        condition.element.hide();
                    }
                });
            }

            return;
        }

        if(loadedModel.selected === false) {
            return loadedModel.emit('deselect');
        }

        showConditions   = null;
        previousSelected = loadedModel.selected;
        var selected     = loadedModel.selected;
        if(!selected || !selected.objectId) {
            hideEverything(inputs, buttons, dropdowns, checkboxes, sliders, iconGroups);
            return;
        }

        if(selected.objectId === 'nodeGui' || selected.objectId === 'nodeData') {
            var nodeData = loadedModel.nodeData[selected.id],
                nodeGui  = loadedModel.nodeGui[selected.id];

            if(!nodeData || !nodeGui) {
                return loadedModel.emit('deselect');
            }

            showNodeMenu(loadedModel, menuItem, inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems, nodeData, nodeGui);
        } else if(selected.objectId === 'link') {
            var link = loadedModel.links[selected.id];
            if(!link) {
                return loadedModel.emit('deselect');
            }

            showConditions = showLinkMenu(loadedModel, menuItem, inputs, buttons, dropdowns, checkboxes, sliders, iconGroups, systems, link);
        }
    };

    menuItem.refresh();

    sidebar.addItem(menuItem);

    var sidebarParent = sidebar.root.parentElement;
    sidebarParent.insertBefore(menuItem.child.root, sidebar.root.nextSibling);

    menuItem.child.root.style.right = '0';
    menuItem.child.root.style.top   = '0';
    menuItem.child.setHeight('100%');
    menuItem.child.root.style['max-height'] = '100%';

    return menuItem;
}

function setupSettingsMenu(sidebar, loadedModel) {
    var menuItem = new NewUI.MenuItem(300);

    menuItem.setLabel('Settings');

    var name = menuItem.addInput('Name');
    name.defaultValue(function() {
        return loadedModel.settings.name;
    });

    name.onChange(function() {
        loadedModel.settings.name = name.getValue();
        loadedModel.emit('resetUI');
    });

    sidebar.addItem(menuItem);
    return menuItem;
}

function addSelectedListeners(sidebar, loadedModel) {
    var selectedMenu = setupSelectedMenu(sidebar, loadedModel);
    var settingsMenu = setupSettingsMenu(sidebar, loadedModel);

    /**
     * @description Deselect all selected nodes.
     * @event deselect
     * @memberof module:model/propagationEvents
     */
    loadedModel.addListener('deselect', function() {
        objectHelper.forEach.call(this.nodeGui, function(gui, id) {
            gui.selected = false;
        });

        selectedMenu.child.fold();

        /**
         * @description Item was deselected by any means.
         * @event deselected
         * @memberof module:model/statusEvents
         *
         * @example tool.addListener('deselected', function() {
         *     console.log('Nothing is selected.');
         * });
         */
        loadedModel.emit('deselected');
    });

    loadedModel.addListener('selectableObjectUpdated', function() {
        selectedMenu.refresh();
    });

    var previousSelected = false;
    /**
     * @description Select a new item under model.selected;
     * @event select
     * @memberof module:model/propagationEvents
     */
    loadedModel.addListener('select', function() {
        if(previousSelected !== loadedModel.selected) {
            selectedMenu.refresh();
            previousSelected = loadedModel.selected;
            if(loadedModel.selected === false) {
                loadedModel.emit('deselect');
            } else {
                selectedMenu.child.unfold();

                /**
                 * @description Item was selected.
                 * @event selected
                 * @memberof module:model/statusEvents
                 *
                 * @param {object} selected - The currently selected object.
                 * @example tool.addListener('selected', function(object) {
                 *     if(object.objectId !== 'nodeData' && object.objectId !== 'nodeGui') {
                 *         return console.log('Not a node.');
                 *     }
                 *     
                 *     var nodeData = this.nodeData[this.selected.id];
                 *     var nodeGui  = this.nodeGui[this.selected.id];
                 *     console.log('Node selected', nodeData, nodeGui);
                 * });
                 */
                loadedModel.emit(this.selected, 'selected');
            }
        }
    });
}

module.exports = addSelectedListeners;
