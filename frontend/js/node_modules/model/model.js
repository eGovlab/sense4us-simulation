'use strict';

/**
 * Model layer for model related helper methods.
 * @module model
 */

var network         = require('network'),
    breakout        = require('breakout'),
    Scenario        = require('scenario'),
    Emitter         = require('emitter'),
    Promise         = require('promise'),

    createNode      = require('structures').createNode,
    createLink      = require('structures').createLink,

    objectHelper    = require('object-helper'),
    
    settings        = require('settings');

/**
 * @description Model constructor
 * @see {@link model/Model}
 * @class
 *
 * @param {integer} id - Model id, should probably be unique.
 * @param {object} data - Data to override keys on construction.
 */

function Model(id, data) {
    this.listeners = {};

    /** @member {object} */
    this.changed     = {};
    /** @member {object} */
    this.timestamps  = {};

    /** @member {integer} */
    this.id          = typeof id === 'number' ? id : null;
    /** @member {integer} */
    this.syncId      = false;
    /** @member {boolean} */
    this.saved       = false;
    /** @member {boolean} */
    this.synced      = false;

    /** @member {integer} */
    this.nextId      = 0;
    /** @member {object} */
    this.nodeData    = {};
    /** @member {object} */
    this.nodeGui     = {};
    /** @member {object} */
    this.links       = {};

    /** @member {array} */
    this.history         = [];
    /** @member {array} */
    this.revertedHistory = [];

    /** @member {object} */
    this.selected        = false;
    /** @member {string} */
    this.environment     = 'modelling';
    /** @member {object} */
    this.sidebar         = settings.sidebar;
    /** @member {array} */
    this.floatingWindows = [];

    /** @member {object} */
    this.settings = {
        name:          'New Model',
        //maxIterations: 4,
        offsetX:       0,
        offsetY:       0,
        zoom:          1,
        linegraph:     false,
        objectId:      'modelSettings',
        id:            0

        //timeStepT:     'Week',
        //timeStepN:     0
    };

    /** @member {object} */
    this.scenarios      = {};
    var __ = new Scenario(this);
    this.scenarios[__.id] = __;

    /** @member {object} */
    this.loadedScenario = __;

    if(data) {
        Object.keys(data).forEach(function(key) {
            this[key] = data[key];
        }, this);
    }

    /** @member {string} */
    this.objectId = 'model';
}

/** @module model/api */

Model.prototype = {__proto__: Emitter.prototype};

/**
 * @description Push a state of history onto the stack for undo/redo.
 * @name pushHistory
 * @function
 *
 * @param {object} state - A struct of history state.
 * @param {string} state.action - History action.
 * @param {object} state.data - Data relevant to undo and redo history.
 */
Model.prototype.pushHistory = function(data) {
    if(!data.action) {
        return;
    }

    this.history.push(data);
    this.revertedHistory = [];
};

/**
 * @description Generate and return the next id.
 * @name generateId
 * @function
 *
 * @returns {integer}
 */
Model.prototype.generateId = function() {
    return ++this.nextId;
};

Model.prototype.deselect = function() {
    var selectedObject = this.selected;
    if(!selectedObject) {
        return Promise.resolve(null);
    }

    this.selected.selected = false;
    this.selected          = null;

    this.emit('deselected', selectedObject);
    return Promise.resolve(selectedObject);
};

Model.prototype.selectByName = function(name) {
    for(let nodeId in this.nodeGui) {
        let node = this.nodeGui[nodeId];
        if(node.name === name) {
            var that = this;
            return this.deselect().then(function() {
                node.selected = true;
                that.selected = node;

                that.emit('selected', node);
                return node;
            });
        }
    }

    return Promise.reject(new Error('No node found on name: ' + name));
};

Model.prototype.selectById = function(id) {
    if(!this.nodeGui[id] && !this.links[id]) {
        return Promise.reject(new Error('No item by given id: ' + id));
    }

    if(this.nodeGui[id]) {
        this.nodeGui[id].selected = true;
        this.selected             = this.nodeGui[id];
    } else {
        this.links[id].selected = true;
        this.selected           = this.links[id];
    }

    this.emit('selected', this.selected);
    return Promise.resolve(this.selected);
};

Model.prototype.selectNodeByPrototypeId = function(prototypeId) {
    for(let nodeId in this.nodeGui) {
        let node = this.nodeGui[nodeId];
        if(node.prototypeId === prototypeId) {
            var that = this;
            return this.deselect().then(function() {
                node.selected = true;
                that.selected = node;

                that.emit('selected', node);
                return node;
            });
        }
    }

    return Promise.reject(new Error('No node found on prototype id: ' + prototypeId));
};

Model.prototype.selectNode = function(query) {
    if(query === undefined) {
        return Promise.reject(new Error('No query given to selectNode. Name or node id.'));
    }

    if(typeof query === 'number') {
        return this.selectById(query);
    }

    return this.selectByName(query);
};

Model.prototype.deleteLink = function(id) {
    var link = this.links[id];
    if(!link) {
        return Promise.reject(new Error('No link under id: ' + id));
    }

    var upstream   = this.nodeGui[link.node1];
    var downstream = this.nodeGui[link.node2];

    var index = upstream.links.indexOf(link.id);
    if(index !== -1) {
        upstream.links.splice(index, 1);
    }

    var index = downstream.links.indexOf(link.id);
    if(index !== -1) {
        downstream.links.splice(index, 1);
    }

    delete this.links[link.id];
    this.emit('deletedLink', link);

    return Promise.resolve(link);
};

Model.prototype.deleteNode = function(id) {
    if(!id || !this.nodeData[id]) {
        return Promise.reject(new Error('No node under id: ' + id));
    }

    var selectedNodeData = this.nodeData[id];
    var selectedNodeGui  = this.nodeGui[id];

    var c = Promise.resolve();
    if(selectedNodeGui.links) {
        var that = this;
        selectedNodeGui.links.forEach(function(link, key) {
            c = c.then(function() {
                return that.deleteLink(link);
            });
        });
    }

    var that = this;
    return c.then(function() {
        delete that.nodeData[selectedNodeData.id];
        that.emit('deletedNodeData', selectedNodeData);

        delete that.nodeGui[selectedNodeGui.id];
        that.emit('deletedNodeGui', selectedNodeGui);

        return Promise.resolve(selectedNodeData);
    });
};

Model.prototype.deleteSelectedLink = function() {
    if(!this.selected) {
        return Promise.reject(new Error('Nothing selected.'));
    }

    var objectId = this.selected.objectId
    if(objectId !== 'link') {
        return Promise.reject(new Error('Trying to delete a link, but there is no link selected.'));
    }

    var that = this;
    var deletingItem = that.selected;
    return this.deselect().then(function() {
        return that.deleteLink(deletingItem.id);
    });
};

Model.prototype.deleteSelectedNode = function() {
    if(!this.selected) {
        return Promise.reject(new Error('Nothing selected.'));
    }

    var objectId = this.selected.objectId
    if(objectId !== 'nodeData' && objectId !== 'nodeGui') {
        return Promise.reject(new Error('Trying to delete a node, but there is no node selected.'));
    }

    var that = this;
    var deletingItem = that.selected;
    return this.deselect().then(function() {
        return that.deleteNode(deletingItem.id);
    });
};

Model.prototype.deleteSelected = function() {
    if(!this.selected) {
        return Promise.reject(new Error('Nothing selected.'));
    }

    var objectId = this.selected.objectId;
    if(objectId === 'nodeData' || objectId === 'nodeGui') {
        return this.deleteSelectedNode();
    } else if(objectId === 'link') {
        return this.deleteSelectedLink();
    }

    return Promise.reject(new Error('Something is selected but we can\'t delete it for some reason.'));
};

function generateHexColor() {
    var n = Math.round(Math.random() * 255).toString(16);

    if(n.length === 1) {
        n = '0' + n;
    }

    return n;
}

function generateColor() {
    return '#' + generateHexColor() + generateHexColor() + generateHexColor();
}

Model.prototype.createActor = function(data, gui) {
    if(!data) {
        data = {};
    }

    if(!gui) {
        gui = {};
    }

    gui.color = generateColor();

    return this.createNode(data, gui, 'actor');
};

Model.prototype.createOrigin = function(data, gui) {
    if(!data) {
        data = {};
    }

    if(!gui) {
        gui = {};
    }

    return this.createNode(data, gui, 'origin');
};

Model.prototype.createNode = function(data, gui, type) {
    var id = this.generateId();
    var nodeData = {
        syncId:          false,
        value:           0,
        simulateChange:  [],
        type:            type || 'intermediate',
        initialValue:    0,
        measurementUnit: '',
        description:     '',
        baseline:        0,

        objectId: 'nodeData'
    };

    var x      = 600;
    var y      = 100;
    var radius = gui ? gui.radius || 45 : 45;

    var offsetX     = this.settings.offsetX;
    var offsetY     = this.settings.offsetY;

    objectHelper.forEach.call(this.nodeGui, function(n) {
        if(n.x > x) {
            x = n.x;
        }
    });

    x += radius;

    var nodeGui = {
        x:        x,
        y:        y,
        radius:   radius,
        links:    [],
        color:    '',

        objectId: 'nodeGui'
    };


    if(data !== undefined) {
        nodeData = objectHelper.merge.call(nodeData, data);
    }

    if(gui !== undefined) {
        nodeGui = objectHelper.merge.call(nodeGui, gui);
    }

    nodeData.id = id;
    nodeGui.id  = id;
    
    this.history.push({
        action: 'newNode',
        data:   {
            data: nodeData,
            gui:  nodeGui
        }
    });

    this.revertedHistory = [];

    this.nodeData[id] = nodeData;
    this.nodeGui[id]  = nodeGui;

    this.emit('resetUI');
    this.emit('refresh');

    /**
     * @description A new node has been created.
     * @event newNode
     * @memberof module:model/statusEvents
     *
     * @param {integer} id - New node id.
     * @param {object} nodeData - Data relevant to the new node.
     * @param {object} nodeGui - Gui data relevant to the new node.
     * @example tool.addListener('newNode', function(id, nodeData, nodeGui) {
     *     console.log(nodeData, nodeGui);
     * })
     */

    this.emit('newNode', id, nodeData, nodeGui);

    return Promise.resolve(nodeData);
};

Model.prototype.createLink = function(source, destination) {
    if(!this.nodeData[source] || !this.nodeData[destination]) {
        return Promise.reject(new Error('Either source- or destination node does not exist.'));
    }

    var link = {
        id:            this.generateId(),
        node1:         source,
        node2:         destination,
        coefficient:   1,
        type:          type || 'fullchannel',
        timelag:       0,
        threshold:     0,
        width:         8,
        objectId:      'link',
        bidirectional: false,
        bidirectionalTimelag: 0
    };

    this.links[link.id] = link;

    this.emit('newLink', link);
    this.emit('refresh');
    return Promise.resolve(link);
};

module.exports = Model;