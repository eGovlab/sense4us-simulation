'use strict';

/**
 * Model layer for model related helper methods.
 * @module model_layer
 */

var network         = require('network'),
    Immutable       = null,
    breakout        = require('breakout'),
    Scenario        = require('scenario'),
    Promise         = require('promise'),

    createNode      = require('structures').createNode,
    createLink      = require('structures').createLink,

    objectHelper    = require('object-helper'),
    
    settings        = require('settings');

module.exports = {
    newModel: function(data) {
        generateId++;
        return new Model(generateId, data);
    },

    moveModel: function(model) {
        var newModel = this.newModel();

        newModel.CONFIG          = model.CONFIG;
        newModel.id              = model.id;
        newModel.environment     = model.environment;
        newModel.sidebar         = model.sidebar;
        newModel.floatingWindows = model.floatingWindows;
        newModel.saved           = model.saved;
        newModel.synced          = model.synced;
        newModel.syncId          = model.syncId;
        newModel.nextId          = model.nextId;
        
        // Saving and reloading the current model would fuck up the sidebar
        // if this property existed, since it would overwrite the currently selected value.
        delete newModel.selected;
        newModel.nodeData        = model.nodeData;
        newModel.nodeGui         = model.nodeGui;
        newModel.links           = model.links;
        newModel.settings        = model.settings;
        newModel.treeSettings    = model.treeSettings;
        newModel.loadedScenario  = model.loadedScenario;
        newModel.scenarios       = model.scenarios;
        newModel.listeners       = model.listeners;
        newModel.static          = model.static;
        newModel.history         = model.history;

        /*model.floatingWindows.forEach(function(floatingWindow) {
            floatingWindow.destroyWindow();

            if(floatingWindow.hide) {
                floatingWindow.hide();
            }
        });*/

        //model.floatingWindows = [];
        model.nodeData        = {};
        model.nodeGui         = {};
        model.links           = {};
        model.treeSettings    = {};
        var _                 = new Scenario(model);
        model.scenarios       = {};
        model.scenarios[_.id] = _;
        model.loadedScenario  = _;
        model.settings        = {};

        model.history         = [];

        return newModel;
    },

    getAllModels: function(loadedModel) {
        return getAllModels.call(loadedModel);
    },

    saveModel: function(url, userFilter, projectFilter, loadedModel, onDone) {
        var data = {
            modelId:   loadedModel.syncId,
            settings:  loadedModel.settings,
            nodes:     breakout.nodes(loadedModel),
            links:     breakout.links(loadedModel),
            scenarios: loadedModel.scenariosToJson()
        };

        console.log(data);

        network(url, '/models/' + userFilter + '/' + projectFilter +'/save', data, function(response, err) {
            if (err) {
                console.error(err.stack);
                loadedModel.emit('Couldn\'t save model: ' + err.message, 'notification');
                return;
            }

            if(response.status !== 200) {
                loadedModel.emit('Couldn\'t save model: ' + (response.errors || 'null'), 'notification');
                return;
            }

            try {
                loadedModel.synced         = true;
                loadedModel.syncId         = response.response.model.id;
                loadedModel.settings.saved = true;

                var nodes      = response.response.nodes;
                var links      = response.response.links;
                var scenarios  = response.response.scenarios;
                var timetables = response.response.timetables;
                var timesteps  = response.response.timesteps;

                var nodeLookup = {};
                nodes.forEach(function(node) {
                    try {
                        loadedModel.nodeData[node.id].syncId = node.syncId;
                        loadedModel.nodeGui[node.id].syncId  = node.syncId;

                        nodeLookup[node.syncId] = loadedModel.nodeData[node.id];
                    } catch(err) {
                        // Node deleted locally before synchronization was made.
                    }
                });

                links.forEach(function(link) {
                    try {
                        loadedModel.links[link.id].syncId = link.syncId;
                    } catch(err) {
                        // Link deleted locally before synchronization was made.
                    }
                });

                var scenarioLookup = {};
                scenarios.forEach(function(scenario) {
                    loadedModel.scenarios[scenario.id].syncId = scenario.syncId;
                    scenarioLookup[scenario.syncId] = loadedModel.scenarios[scenario.id];
                });

                var timetableLookup = {};
                timetables.forEach(function(timetable) {
                    scenarioLookup[timetable.scenario].data[nodeLookup[timetable.node].id].syncId = timetable.syncId;
                    timetableLookup[timetable.syncId] = scenarioLookup[timetable.scenario].data[nodeLookup[timetable.node]];
                });

                /*timesteps.forEach(function(timestep) {
                    timetableLookup[timestep.timetable]
                });*/

                /*loadedModel = loadedModel.set('syncId',   response.response.id);
                loadedModel = loadedModel.set('settings', loadedModel.settings.set('saved', true));
                _loadedModel(loadedModel);*/

                /*if(response.response.message) {
                    loadedModel.emit(response.response.message, 'notification');
                } else {
                    loadedModel.emit('Model['+loadedModel.settings.name+'] saved.', 'notification');
                }*/

            } catch(e) {
                console.error(e);
                throw e;
            }

            onDone();
        });
    },

    deleteModel: function(url, userFilter, projectFilter, modelId, savedModels, callback) {
        var that = this;
        if(savedModels.local[modelId] === undefined) {
            network(url, '/models/' + userFilter + '/' + projectFilter + '/' + modelId, {}, function(response, err) {
                if(err) {
                    console.error(response);
                    console.error(err);
                    return;
                }

                //delete savedModels.local[loadedModel.id];
                delete savedModels.synced[modelId];

                callback(response.response.message);
            }, 'DELETE');
        } else {
            delete savedModels.local[modelId];
            callback();
        }
    },
    
    loadSyncModel: function(url, userFilter, projectFilter, modelId, callback) {
        var that = this;
        network(url, '/models/' + userFilter + '/' + projectFilter + '/bundle/' + modelId, function(response, error) {
            if (error) {
                console.error(response);
                console.error(error);
                return;
            }

            if(response.status !== 200) {
                if(!response.response) {
                    response.response = {};
                }
                callback(new Error(response.response.message || 'Error loading model'));
                return;
            }

            var settings   = response.response.model,
                nodes      = response.response.nodes,
                links      = response.response.links,
                scenarios  = response.response.scenarios,
                timetables = response.response.timetables,
                timesteps  = response.response.timesteps;

            var newState = that.newModel();
            newState.synced = true;
            newState.syncId = settings.id;
            delete newState.scenarios;

            var highestId = 0;

            newState.scenarios = {};
                    /*name:          'New Model',
                    maxIterations: 4,
                    offsetX:       0,
                    offsetY:       0,
                    zoom:          1,
                    linegraph:     false,

                    timeStepT:     'Week',
                    timeStepN:     0*/
            /*newState.settings = {
                name:          settings.name,
                offsetX:       settings.pan_offset_x,
                offsetY:       settings.pan_offset_y,
                zoom:          settings.zoom
            };*/

            newState.settings.name    = settings.name;
            newState.settings.offsetX = settings.pan_offset_x;
            newState.settings.offsetY = settings.pan_offset_y;
            newState.settings.zoom    = settings.zoom;

            nodes.forEach(function(node) {
                newState.nodeData[node.id] = {
                    id:             node.id,
                    syncId:         node.id,
                    name:           node.name,
                    description:    node.description,
                    type:           node.type,
                    prototypeId:    node.prototype_id,
                    role:           node.role,
                    simulateChange: 0,
                    baseline:       node.baseline || 0,

                    objectId:       'nodeData'
                };

                newState.nodeGui[node.id]  = {
                    id:         node.id,
                    syncId:     node.id,
                    radius:     node.radius,
                    x:          node.x,
                    y:          node.y,
                    avatar:     node.avatar,
                    color:      node.color,
                    links:      [],

                    objectId:   'nodeGui'
                };

                if(highestId < node.id) {
                    highestId = node.id;
                }
            });

            links.forEach(function(link) {
                if(!link.downstream || !link.upstream) {
                    return callback(settings.id);
                }

                newState.links[link.id] = {
                    id:          link.id,
                    syncId:      link.id,
                    coefficient: link.coefficient,
                    node1:       link.upstream,
                    node2:       link.downstream,
                    threshold:   link.threshold,
                    timelag:     link.timelag,
                    type:        link.type || 'fullchannel',
                    width:       8,

                    bidirectional:        link.bidirectional         || false,
                    bidirectionalTimelag: link.bidirectional_timelag || 1,

                    objectId:    'link'
                };

                newState.nodeGui[link.downstream].links.push(link.id);
                newState.nodeGui[link.upstream].links.push(link.id);

                if(highestId < link.id) {
                    highestId = link.id;
                }
            });

            scenarios.forEach(function(scenario, index) {
                var newScenario = {
                    id:                 scenario.id,
                    syncId:             scenario.id,
                    name:               scenario.name,
                    maxIterations:      scenario.max_iterations,
                    timeStepN:          scenario.timestep_n,
                    measurement:        scenario.measurement,
                    measurementAmount:  scenario.measurement_amount,
                    data:               {}
                };//new Scenario(newState);

                newState.scenarios[newScenario.id] = newScenario;

                if(index === 0) {
                    newState.loadedScenario = newState.scenarios[scenario.id];
                }

                if(highestId < scenario.id) {
                    highestId = scenario.id;
                }
            });

            /*
            ** table: {id, node: id, scenario: id}
            ** step: {id, step: key, timetable: id, value: float}
            */

            var timetableLookup = {};
            console.log(timetables, timesteps);
            timetables.forEach(function(timetable) {
                var node = newState.nodeData[timetable.node];
                var timetableStructure = {
                    id:          timetable.id,
                    syncId:      timetable.id,
                    realNumbers: timetable.real_numbers,
                    /*scenario: timetable.scenario,
                    node:     timetable.node,*/
                    steps:       {}
                };

                newState.scenarios[timetable.scenario].data[node.id] = timetableStructure;
                timetableLookup[timetableStructure.id] = timetableStructure;
            });

            timesteps.forEach(function(timestep) {
                if(!timetableLookup[timestep.timetable]) {
                    console.log(timestep, 'didn\'t have a timetable?');
                    return;
                }

                var steps = timetableLookup[timestep.timetable].steps;
                steps[timestep.step] = timestep.value;
            });

            /*timetableLookup.forEach(function(tt) {
                tt.refreshTimeTable();
            });*/

            newState.nextId = ++highestId;

            callback(newState);
        });
    }
};
